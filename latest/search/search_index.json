{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mockio","text":"<p>Golang library for mocking without code generation, inspired by Mockito.</p>"},{"location":"#installing-library","title":"Installing library","text":"<p>Install latest version of the library using <code>go get</code> command:</p> Bash<pre><code>go get -u github.com/ovechkin-dm/mockio/v2\n</code></pre>"},{"location":"#creating-test","title":"Creating test","text":"<p>Let's create an interface that we want to mock:</p> Go<pre><code>type Greeter interface {\n    Greet(name string) string\n}\n</code></pre> <p>Now we will use <code>dot import</code> to simplify the usage of the library:</p> Go<pre><code>import (\n    .\"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n</code></pre> <p>Now we can create a mock for the <code>Greeter</code> interface, and test it's method <code>Greet</code>:</p> Go<pre><code>func TestGreet(t *testing.T) {\n    ctrl := NewMockController(t)\n    m := Mock[Greeter](ctrl)\n    WhenSingle(m.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n    if m.Greet(\"John\") != \"Hello, John!\" {\n        t.Fail()\n    }\n}\n</code></pre>"},{"location":"#full-example","title":"Full example","text":"<p>Here is the full listing for our simple test:</p> Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name string) string\n}\n\nfunc TestGreet(t *testing.T) {\n    ctrl := NewMockController(t)\n    m := Mock[Greeter](ctrl)\n    WhenSingle(m.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n    if m.Greet(\"John\") != \"Hello, John!\" {\n        t.Fail()\n    }\n}\n</code></pre> <p>That's it! You have created a mock for the <code>Greeter</code> interface without any code generation. As you can see, the library is very simple and easy to use. And no need to generate mocks for your interfaces.</p>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#architecture","title":"Architecture","text":"<p>Because library uses assembly code to generate mocks, it is not possible to use it in pure Go code.  This means that you cannot use it in a project that is intended to be cross-compiled to multiple platforms.</p> <p>For now supported platforms are:</p> <ul> <li>AMD64</li> <li>ARM64</li> </ul> <p>This list may be extended in the future.</p>"},{"location":"limitations/#backwards-compatibility-and-new-go-versions","title":"Backwards compatibility and new Go versions","text":"<p>This library is tested for GO 1.18 up to 1.23</p> <p>Caution: there is no guarantee that it will work with future versions of Go.  However there is not much that can break the library, so it should be easy to fix it if it stops working. As of latest mockio version, almost all of dependencies on golang internal runtime features were removed.</p> <p>Please refer to go-dyno documentation for more information on compatibility.</p>"},{"location":"sponsors/","title":"Sponsors list","text":"<p>Thanks to all the people who supported this project by donating money,  time or resources:</p> <ul> <li>Ovechkin Dmitry</li> <li>Eray Ates</li> <li>Emilien Puget</li> </ul>"},{"location":"features/captors/","title":"Argument Captors","text":"<p>Argument captors are a powerful feature that allow you to capture the arguments passed to a method when it is called. This is useful when you want to verify that a method was called with specific arguments, but you don't know what those arguments will be ahead of time.</p>"},{"location":"features/captors/#creating-a-captor","title":"Creating a Captor","text":"<p>To create a captor, you simply call the <code>Captor</code> function with the type of the argument you want to capture:</p> Go<pre><code>c := Captor[string]()\n</code></pre>"},{"location":"features/captors/#using-a-captor","title":"Using a Captor","text":"<p>To use a captor, you pass it as an argument to the <code>When</code> function. When the method is called, the captor will capture the argument and store it in the captor's value:</p> Go<pre><code>When(greeter.Greet(c.Capture())).ThenReturn(\"Hello, world!\")\n</code></pre>"},{"location":"features/captors/#retrieving-the-captured-values","title":"Retrieving the Captured Values","text":"<p>Argument captor records an argument on each stub call. You can retrieve the captured values by calling the <code>Values</code> method</p> Go<pre><code>capturedValues := c.Values()\n</code></pre> <p>If you want to retrieve just the last captured value, you can call the <code>Last</code> method</p> Go<pre><code>capturedValue := c.Last()\n</code></pre>"},{"location":"features/captors/#example-usage","title":"Example usage","text":"<p>In this example we will create a mock, and use an argument captor to capture the arguments passed to the <code>Greet</code> method:</p> Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name any) string\n}\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    c := Captor[string]()\n    When(greeter.Greet(c.Capture())).ThenReturn(\"Hello, world!\")\n    _ = greeter.Greet(\"John\")\n    _ = greeter.Greet(\"Jane\")\n    if c.Values()[0] != \"John\" {\n        t.Error(\"Expected John, got\", c.Values()[0])\n    }\n    if c.Values()[1] != \"Jane\" {\n        t.Error(\"Expected Jane, got\", c.Values()[1])\n    }\n}\n</code></pre>"},{"location":"features/configuration/","title":"Configuration","text":""},{"location":"features/configuration/#using-options","title":"Using options","text":"<p>MockIO library can be configured by providing options from <code>mockopts</code> package inside <code>NewMockController()</code> function like this: Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"github.com/ovechkin-dm/mockio/mockopts\"\n    \"testing\"\n)\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.WithoutStackTrace())\n}\n</code></pre></p>"},{"location":"features/configuration/#strictverify","title":"StrictVerify","text":"<p>StrictVerify adds extra checks on each test teardown.  It will fail the test if there are any unverified calls. It will also fail the test if there are any calls that were not expected.</p>"},{"location":"features/configuration/#unverified-calls-check","title":"Unverified calls check","text":"<p>Consider the following example: Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"github.com/ovechkin-dm/mockio/mockopts\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name string) string\n}\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.StrictVerify())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n}\n</code></pre> In this case, the test will fail because the <code>Greet</code> method was not called with the expected argument. If we want this test to pass, we need to call greeter with the expected argument: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.StrictVerify())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n    greeter.Greet(\"John\")\n}\n</code></pre></p>"},{"location":"features/configuration/#unexpected-calls-check","title":"Unexpected calls check","text":"<p>Consider the following example:</p> Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.StrictVerify())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n    greeter.Greet(\"John\")\n    greeter.Greet(\"Jane\")\n}\n</code></pre> <p>In this case, the test will fail because the <code>Greet</code> method was called with an unexpected argument. If we want this test to pass, we need to remove the unexpected call, or add an expectation for it: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.StrictVerify())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"Hello, John!\")\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"Hello, Jane!\")\n    greeter.Greet(\"John\")\n    greeter.Greet(\"Jane\")\n}\n</code></pre></p>"},{"location":"features/configuration/#withoutstacktrace","title":"WithoutStackTrace","text":"<p>WithoutStackTrace option disables stack trace printing in case of test failure.</p> <p>Consider the following example: Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name string) string\n}\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.StrictVerify())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    VerifyNoMoreInteractions(greeter)\n}\n</code></pre></p> <p>If we run this test, we will see the following error: Text Only<pre><code>=== RUN   TestSimple\n    reporter.go:75: At:\n            go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45\n        Cause:\n            No more interactions expected, but unverified interactions found:\n                Greeter.Greet(John) at demo/hello_test.go:16 +0xf2\n        Trace:\n        demo.TestSimple.VerifyNoMoreInteractions.VerifyNoMoreInteractions.func1()\n            go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45\n        demo.TestSimple(0xc00018c4e0?)\n            demo/hello_test.go:17 +0x15a\n        testing.tRunner(0xc00018c4e0, 0x647ca0)\n            /usr/local/go/src/testing/testing.go:1689 +0xfb\n        created by testing.(*T).Run in goroutine 1\n            /usr/local/go/src/testing/testing.go:1742 +0x390\n\n--- FAIL: TestSimple (0.00s)\n\nFAIL\n</code></pre></p> <p>By adding <code>mockopts.WithoutStackTrace()</code> to the <code>SetUp</code> function, we can disable stack trace printing: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t, mockopts.WithoutStackTrace())\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    VerifyNoMoreInteractions(greeter)\n}\n</code></pre></p> <p>Now the error will look like this: Text Only<pre><code>=== RUN   TestSimple\n    reporter.go:75: At:\n            go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45\n        Cause:\n            No more interactions expected, but unverified interactions found:\n                Greeter.Greet(John) at demo/hello_test.go:17 +0x10b\n--- FAIL: TestSimple (0.00s)\n\nFAIL\n</code></pre></p>"},{"location":"features/error-reporting/","title":"Error reporting","text":"<p><code>Mockio</code> library supports providing custom error reporting in <code>NewMockController</code> function. This can be helpful if you want to introduce custom error reporting or logging. Reporter should implement <code>ErrorReporter</code> interface. Go<pre><code>type ErrorReporter interface {\n    Fatalf(format string, args ...any)\n    Errorf(format string, args ...any)\n    Cleanup(func())\n}\n</code></pre></p> <ul> <li><code>Fatalf</code> - should be used to report fatal errors. It should stop the test execution.</li> <li><code>Errorf</code> - should be used to report non-fatal errors. It should continue the test execution.  </li> <li><code>Cleanup</code> - should be used to register a cleanup function. It should be called after the test execution.</li> </ul>"},{"location":"features/error-reporting/#error-output","title":"Error output","text":""},{"location":"features/error-reporting/#incorrect-when-usage","title":"Incorrect <code>When</code> usage","text":"<p>Example:</p> Go<pre><code>When(1)\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:22 +0xad\nCause:\n    When() requires an argument which has to be 'a method call on a mock'.\n    For example: When(mock.GetArticles()).ThenReturn(articles)\n</code></pre></p>"},{"location":"features/error-reporting/#non-mock-verification","title":"Non-mock verification","text":"<p>Example:</p> Go<pre><code>Verify(100, Once())\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:46 +0x105\nCause:\n    Argument passed to Verify() is 100 and is not a mock, or a mock created in a different goroutine.\n    Make sure you place the parenthesis correctly.\n    Example of correct verification:\n        Verify(mock, Times(10)).SomeMethod()\n</code></pre></p>"},{"location":"features/error-reporting/#invalid-use-of-matchers","title":"Invalid use of matchers","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), 10)).ThenReturn(10)\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:55 +0x110\nCause:\n    Invalid use of matchers\n    3 expected, 2 recorded:\n        /demo/error_reporting_test.go:55 +0xab\n        /demo/error_reporting_test.go:55 +0xbc\n    method:\n        Foo.Baz(int, int, int) int\n    expected:\n        (int,int,int)\n    got:\n        (Any[int],Any[int])\n    This can happen for 2 reasons:\n        1. Declaration of matcher outside When() call\n        2. Mixing matchers and exact values in When() call. Is this case, consider using \"Exact\" matcher.\n</code></pre></p>"},{"location":"features/error-reporting/#expected-method-call","title":"Expected method call","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)\n_ = mock.Baz(10, 10, 11)\nVerify(mock, Once()).Baz(AnyInt(), AnyInt(), Exact(10))\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:88 +0x262\nCause:\n    expected num method calls: 1, got : 0\n        Foo.Baz(Any[int], Any[int], Exact(10))\n    However, there were other interactions with this method:\n        Foo.Baz(10, 10, 11) at /demo/error_reporting_test.go:87 +0x193\n</code></pre></p>"},{"location":"features/error-reporting/#number-of-method-calls","title":"Number of method calls","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)\n_ = mock.Baz(10, 10, 10)\nVerify(mock, Times(20)).Baz(AnyInt(), AnyInt(), AnyInt())\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:121 +0x25a\nCause:\n    expected num method calls: 20, got : 1\n        Foo.Baz(Any[int], Any[int], Any[int])\n    Invocations:\n        /demo/error_reporting_test.go:120 +0x191\n</code></pre></p>"},{"location":"features/error-reporting/#empty-captor","title":"Empty captor","text":"<p>Example:</p> Go<pre><code>c := Captor[int]()\n_ = c.Last()\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:130 +0x92\nCause:\n    no values were captured for captor\n</code></pre></p>"},{"location":"features/error-reporting/#invalid-return-values","title":"Invalid return values","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10, 20)\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/error_reporting_test.go:140 +0x1a7\nCause:\n    invalid return values\nexpected:\n    Foo.Baz(int, int, int) int\ngot:\n    Foo.Baz(int, int, int) (string, int)\n</code></pre></p>"},{"location":"features/error-reporting/#no-more-interactions","title":"No more interactions","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(\"test\", 10)\n_ = mock.Baz(10, 10, 10)\n_ = mock.Baz(10, 20, 10)\nVerifyNoMoreInteractions(mock)\n</code></pre> <p>Output: Text Only<pre><code>At:\n    /demo/mockio/registry/registry.go:130 +0x45\nCause:\n    No more interactions expected, but unverified interactions found:\n        Foo.Baz(10, 10, 10) at /demo/error_reporting_test.go:150 +0x1a8\n        Foo.Baz(10, 20, 10) at /demo/error_reporting_test.go:151 +0x1c6\n</code></pre></p>"},{"location":"features/error-reporting/#unexpected-matcher-declaration","title":"Unexpected matcher declaration","text":"<p>Example:</p> Go<pre><code>When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)\nmock.Baz(AnyInt(), AnyInt(), AnyInt())\nVerify(mock, Once()).Baz(10, 10, 10)\n</code></pre> Go<pre><code>At:\n    /demo/error_reporting_test.go:175 +0x23f\nCause:\n    Unexpected matchers declaration.\n        at /demo/error_reporting_test.go:174 +0x185\n        at /demo/error_reporting_test.go:174 +0x196\n        at /demo/error_reporting_test.go:174 +0x1a7\n    Matchers can only be used inside When() method call.\n</code></pre>"},{"location":"features/matchers/","title":"Matchers","text":"<p>MockIO library provides a lot of ways to match arguments of the method calls. Matchers are used to define the expected arguments of the method calls.</p> <p>We will use the following interface for the examples: Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name any) string\n}\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)    \n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n}\n</code></pre></p>"},{"location":"features/matchers/#any","title":"Any","text":"<p>The <code>Any[T]()</code> matcher matches any value of the type <code>T</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Any[string]())).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#anyint","title":"AnyInt","text":"<p>The <code>AnyInt()</code> matcher matches any integer value. </p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Any[int]())).ThenReturn(\"hello world\")\n    if greeter.Greet(10) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre> This test will fail, because the argument is not an integer: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Any[int]())).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#anystring","title":"AnyString","text":"<p>The <code>AnyString()</code> matcher matches any string value.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Any[string]())).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre> This test will fail, because the argument is not a string: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Any[int]())).ThenReturn(\"hello world\")\n    if greeter.Greet(10) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#anyinterface","title":"AnyInterface","text":"<p>The <code>AnyInterface()</code> matcher matches any value of any type.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(AnyInterface())).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will also succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(AnyInterface())).ThenReturn(\"hello world\")\n    if greeter.Greet(10) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#anycontext","title":"AnyContext","text":"<p>The <code>AnyContext()</code> matcher matches any context.Context value.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(AnyContext())).ThenReturn(\"hello world\")\n    if greeter.Greet(context.Background()) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#anyoftype","title":"AnyOfType","text":"<p>The <code>AnyOfType[T](t T)</code> matcher matches any value of the type <code>T</code> or its subtype. It is useful for type inference.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(AnyOfType(10))).ThenReturn(\"hello world\")\n    if greeter.Greet(10) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre> Note that when we are using AnyOfType, we don't need to specify the type explicitly.</p>"},{"location":"features/matchers/#nil","title":"Nil","text":"<p>The <code>Nil[T]()</code> matcher matches any nil value of the type <code>T</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Nil[any]())).ThenReturn(\"hello world\")\n    if greeter.Greet(nil) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#notnil","title":"NotNil","text":"<p>The <code>NotNil[T]()</code> matcher matches any non-nil value of the type <code>T</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(NotNil[any]())).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(NotNil[any]())).ThenReturn(\"hello world\")\n    if greeter.Greet(nil) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#regex","title":"Regex","text":"<p>The <code>Regex(pattern string)</code> matcher matches any string that matches the regular expression <code>pattern</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Regex(\"J.*\"))).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#substring","title":"Substring","text":"<p>The <code>Substring(sub string)</code> matcher matches any string that contains the substring <code>sub</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(Substring(\"oh\"))).ThenReturn(\"hello world\")\n    if greeter.Greet(\"John\") != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#slicelen","title":"SliceLen","text":"<p>The <code>SliceLen(length int)</code> matcher matches any slice with the length <code>length</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceLen[int](2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{1, 2}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceLen[int](2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{1, 2, 3}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#maplen","title":"MapLen","text":"<p>The <code>MapLen(length int)</code> matcher matches any map with the length <code>length</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(MapLen[int, string](2))).ThenReturn(\"hello world\")\n    if greeter.Greet(map[int]string{1: \"one\", 2: \"two\"}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(MapLen[int, string](2))).ThenReturn(\"hello world\")\n    if greeter.Greet(map[int]string{1: \"one\", 2: \"two\", 3: \"three\"}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#slicecontains","title":"SliceContains","text":"<p>The <code>SliceContains[T any](values ...T)</code> matcher matches any slice that contains all the values <code>values</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceContains[int](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{1, 2, 3}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceContains[int](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{1, 3}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#mapcontains","title":"MapContains","text":"<p>The <code>MapContains[K any, V any](keys ...K)</code> matcher matches any map that contains all the keys <code>keys</code>.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(MapContains[int, string](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet(map[int]string{1: \"one\", 2: \"two\", 3: \"three\"}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(MapContains[int, string](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet(map[int]string{1: \"one\", 3: \"three\"}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#sliceequalunordered","title":"SliceEqualUnordered","text":"<p>The <code>SliceEqualUnordered[T any](values []T)</code> matcher matches any slice that contains the same elements as <code>values</code>, but in any order.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceEqualUnordered[int](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{2, 1}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(SliceEqualUnordered[int](1, 2))).ThenReturn(\"hello world\")\n    if greeter.Greet([]int{1, 3}) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#exact","title":"Exact","text":"<p>The <code>Exact</code> matcher matches any value that is equal to the expected value. <code>Exact</code> uses <code>==</code> operator to compare values.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    world1 := \"world\"\n    When(greeter.Greet(Exact(&amp;world1))).ThenReturn(\"hello world\")\n    if greeter.Greet(&amp;world1) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p> <p>However, this test will fail, because although the values are equal, they are different pointers: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    world1 := \"world\"\n    world2 := \"world\"\n    When(greeter.Greet(Exact(&amp;world1))).ThenReturn(\"hello world\")\n    if greeter.Greet(&amp;world2) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#equal","title":"Equal","text":"<p>The <code>Equal</code> matcher matches any value that is equal to the expected value. <code>Equal</code> uses <code>reflect.DeepEqual</code> to compare values.</p> <p>This test will succeed, because <code>reflect.DeepEqual</code> compares values by their content: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    world1 := \"world\"\n    world2 := \"world\"\n    When(greeter.Greet(Equal(&amp;world1))).ThenReturn(\"hello world\")\n    if greeter.Greet(&amp;world2) != \"hello world\" {\n        t.Error(\"Expected 'hello world'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#notequal","title":"NotEqual","text":"<p>The <code>NotEqual</code> matcher matches any value that is not equal to the expected value. <code>NotEqual</code> uses <code>reflect.DeepEqual</code> to compare values.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(NotEqual(\"John\"))).ThenReturn(\"hello world\")\n    if greeter.Greet(\"world\") != \"hello world\" {\n        t.Error(\"Expected 'hello John'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#oneof","title":"OneOf","text":"<p>The <code>OneOf</code> matcher matches any value that is equal to one of the expected values. <code>OneOf</code> uses <code>reflect.DeepEqual</code> to compare values.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(OneOf(\"John\", \"Jane\"))).ThenReturn(\"hello John or Jane\")\n    if greeter.Greet(\"Jane\") != \"hello John or Jane\" {\n        t.Error(\"expected 'hello John or Jane'\")\n    }\n}\n</code></pre></p>"},{"location":"features/matchers/#custom-matcher","title":"Custom matcher","text":"<p>Here is an example of a custom matcher that matches odd numbers only:</p> Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    odd := CreateMatcher[int](\"odd\", func(args []any, v int) bool {\n        return v%2 == 1\n    })\n    When(greeter.Greet(odd())).ThenReturn(\"hello odd number\")\n    if greeter.Greet(1) != \"hello odd number\" {\n        t.Error(\"expected ''hello odd number''\")\n    }\n}\n</code></pre>"},{"location":"features/method-stubbing/","title":"Method stubbing","text":"<p>Method stubbing is a technique used in unit testing to replace a method with a stub. A stub is a small piece of code that simulates the behavior of the method it replaces. This allows you to test the behavior of the code that calls the method without actually executing the method itself.</p> <p>Basic usage of method stubbing in Mockio looks like this:</p> Go<pre><code>When(mock.SomeMethod(AnyInt())).ThenReturn(\"some value\")\n</code></pre> <ul> <li><code>When</code> is a function that takes a method call as an argument and returns a <code>Returner</code> object.</li> <li>Inside the method call argument you can use any matcher from the library's API. In this example we used <code>AnyInt()</code> matcher.</li> <li><code>ThenReturn</code> is a method of the <code>Returner</code></li> </ul> <p>This is basic usage of method stubbing. But there are also some useful extensions to this API.</p>"},{"location":"features/method-stubbing/#when","title":"When","text":"<p><code>When</code> is a function that allows you to stub a method. Keep in mind, that <code>When</code> is a generic function, so it does not provide any type check on return value.</p>"},{"location":"features/method-stubbing/#whensingle","title":"WhenSingle","text":"<p><code>WhenSingle</code> is a function that allows you to stub a method to return a single value.  It is almost the same as <code>When</code>, but it provides additional type check on return value.</p> <p>Consider Following interface: Go<pre><code>type Foo interface {\n    Bar(int) string\n}\n</code></pre></p> <p>You can stub <code>Bar</code> method like this: Go<pre><code>WhenSingle(mock.Bar(AnyInt())).ThenReturn(\"some value\")\n</code></pre></p> <p>However, this will not compile: Go<pre><code>WhenSingle(mock.Bar(AnyInt())).ThenReturn(42)\n</code></pre></p> <p>But this will: Go<pre><code>When(mock.Bar(AnyInt())).ThenReturn(42)\n</code></pre></p>"},{"location":"features/method-stubbing/#whendouble","title":"WhenDouble","text":"<p><code>WhenDouble</code> is a function that allows you to stub a method to return two values. It is almost the same as <code>When</code>, but it provides additional type check on return values.</p> <p>Consider Following interface: Go<pre><code>type Foo interface {\n    Bar(int) (string, error)\n}\n</code></pre></p> <p>You can stub <code>Bar</code> method like this: Go<pre><code>WhenDouble(mock.Bar(AnyInt())).ThenReturn(\"some value\", nil)\n</code></pre></p> <p>However, this will not compile: Go<pre><code>WhenDouble(mock.Bar(AnyInt())).ThenReturn(\"some value\", 42)\n</code></pre></p> <p>But this will: Go<pre><code>When(mock.Bar(AnyInt())).ThenReturn(\"some value\", 42)\n</code></pre></p>"},{"location":"features/method-stubbing/#thenanswer","title":"ThenAnswer","text":"<p><code>Answer</code> is a function that allows you to stub a method to return a value based on the arguments passed to the method.</p> <p>Consider following interface: Go<pre><code>type Foo interface {\n    Bar(int) string\n}\n</code></pre></p> <p>You can stub <code>Bar</code> method like this: Go<pre><code>ctrl := NewMockController(t)\nmock := Mock[Foo](ctrl)\nWhenSingle(mock.Bar(AnyInt())).ThenAnswer(func(args []any) string {\n    return fmt.Sprintf(\"Hello, %d\", args[0].(int))\n})\n</code></pre></p> <p>When <code>Bar</code> method is called with argument <code>42</code>, it will return <code>\"Hello, 42\"</code>.</p>"},{"location":"features/method-stubbing/#thenreturn","title":"ThenReturn","text":"<p>You can chain multiple <code>ThenReturn</code> calls to return different values on subsequent calls:</p> Go<pre><code>When(mock.SomeMethod(AnyInt())).\n    ThenReturn(\"first value\").\n    ThenReturn(\"second value\")\n</code></pre> <p>Calling <code>SomeMethod</code> first time will return <code>\"first value\"</code>, second time <code>\"second value\"</code>, and so on.</p>"},{"location":"features/method-stubbing/#implicit-exact-matchers","title":"Implicit <code>Exact</code> matchers","text":"<p>Consider following interface:</p> Go<pre><code>type Foo interface {\n    Bar(int, int) string\n}\n</code></pre> <p>To stub <code>Bar</code> method, we can use something like this: Go<pre><code>When(mock.Bar(Exact(1), Exact(2))).ThenReturn(\"some value\")\n</code></pre></p> <p>However, this can be simplified to: Go<pre><code>When(mock.Bar(1, 2)).ThenReturn(\"some value\")\n</code></pre></p> <p>In short, you can omit using matchers when you want to match exact values, but they all should be exact. For example, this will not work: Go<pre><code>When(mock.Bar(1, Exact(2))).ThenReturn(\"some value\")\n</code></pre></p>"},{"location":"features/parallel-execution/","title":"Parallel execution","text":""},{"location":"features/parallel-execution/#parallelism","title":"Parallelism","text":"<p>It is possible to run multiple tests with mockio in parallel using the <code>--parallel</code> option. This option is available in the <code>test</code> and <code>run</code> commands.</p>"},{"location":"features/parallel-execution/#concurrency","title":"Concurrency","text":"<p>Library supports invoking stubbed methods from different goroutine.</p> Go<pre><code>func TestParallelSuccess(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    wg := sync.WaitGroup{}\n    wg.Add(2)\n    When(greeter.Greet(\"John\")).ThenReturn(\"hello world\")\n    go func() {\n        greeter.Greet(\"John\")\n        wg.Done()\n    }()\n    go func() {\n        greeter.Greet(\"John\")\n        wg.Done()\n    }()\n    wg.Wait()\n    Verify(greeter, Times(2)).Greet(\"John\")\n}\n</code></pre>"},{"location":"features/verification/","title":"Verification","text":"<p>We will use the following interface for the examples: Go<pre><code>package main\n\nimport (\n    . \"github.com/ovechkin-dm/mockio/v2/mock\"\n    \"testing\"\n)\n\ntype Greeter interface {\n    Greet(name any) string\n}\n\nfunc TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n\n}\n</code></pre></p>"},{"location":"features/verification/#verify","title":"Verify","text":"<p>To verify that a method was called, use the <code>Verify</code> function.  If the method was called, the test will pass. If the method was not called, the test will fail.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    Verify(greeter, Once()).Greet(\"John\")\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    Verify(greeter, Once()).Greet(\"Jane\")\n}\n</code></pre></p>"},{"location":"features/verification/#atleastonce","title":"AtLeastOnce","text":"<p>Verify that a method was called at least once: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](t)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    Verify(greeter, AtLeastOnce()).Greet(\"John\")\n}\n</code></pre></p>"},{"location":"features/verification/#once","title":"Once","text":"<p>Verify that a method was called exactly once: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](t)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    Verify(greeter, Once()).Greet(\"John\")\n}\n</code></pre></p>"},{"location":"features/verification/#times","title":"Times","text":"<p>Verify that a method was called a specific number of times: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](t)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    greeter.Greet(\"John\")\n    Verify(greeter, Times(2)).Greet(\"John\")\n}\n</code></pre></p>"},{"location":"features/verification/#verifynomoreinteractions","title":"VerifyNoMoreInteractions","text":"<p>To verify that no other methods were called on the mock object, use the <code>VerifyNoMoreInteractions</code> function. It will fail the test if there are any unverified calls.</p> <p>This test will succeed: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"Jane\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    Verify(greeter, Once()).Greet(\"John\")\n    VerifyNoMoreInteractions(greeter)\n}\n</code></pre></p> <p>This test will fail: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"hello world\")\n    greeter.Greet(\"John\")\n    VerifyNoMoreInteractions(greeter)\n}\n</code></pre></p>"},{"location":"features/verification/#verify-after-thenreturn","title":"Verify after <code>ThenReturn</code>","text":"<p>Since it is common to actually verify that a stub was used correctly, you can use the <code>Verify</code> function after the <code>ThenReturn</code> function: Go<pre><code>func TestSimple(t *testing.T) {\n    ctrl := NewMockController(t)\n    greeter := Mock[Greeter](ctrl)\n    When(greeter.Greet(\"John\")).ThenReturn(\"hello world\").Verify(Once())\n    greeter.Greet(\"John\")\n    VerifyNoMoreInteractions(greeter)\n}\n</code></pre></p>"}]}